‍

OOM结合项目

‍

# 概念

‍

‍

## 零碎

‍

‍

‍

‍

‍

### static变量存储位置

在JDK 7之前，静态变量存储在永久代（PermGen）中。 永久代是方法区的一部分，用于存储类的元数据，包括类的静态变量、常量池、方法数据等。

从JDK 7->JDK 8 (8)完全移除了永久代，取而代之的是元空间（Metaspace），静态变量存储在其对应的Class对象中。而Class对象作为对象，和其他普通对象一样，都是存在java堆中的。

‍

‍

‍

### JVM 运行时数据区域 RDA 包含哪几部分?

> RDA从类加载子系统拿到目标, 在RDA这个大搅拌机里面处理 <-> 执行引擎

RuntimeDataArea

‍

* 堆 Heap
* 栈 Stack

  1. 本地方法栈 Native Method Stack
  2. 虚拟机栈 Java Virtual Machine Stack
* 程序计数器 Program Counter Register
* 方法区 Method Area

‍

‍

### JVM 执行流程极速版

JVM 的执行流程是，首先先把 Java 代码（.java）转化成字节码（.class），然后通过类加载器将字节码加载到内存中，所谓的内存也就是我们上面介绍的运行时数据区，但字节码并不是可以直接交给操作系统执行的机器码，而是一套 JVM 的指令集。这个时候需要使用特定的命令解析器也就是我们俗称的**执行引擎（Execution Engine）** 将字节码翻译成可以被底层操作系统执行的指令再去执行，这样就实现了整个 Java 程序的运行，这也是 JVM 的整体执行流程。

‍

‍

#### Java 内存区域和 JMM 有何区别？

‍

完全不一样的两个东西：JVM / JUC

* JVM 内存结构 和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。
* Java 内存模型和 **Java 的并发编程**相关，抽象了线程和主内存之间的关系

  就比如说线程之间的**共享变量**必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。

‍

‍

### 远程调试IDE原理

IDEA远程调试通过附加到JVM的原理主要涉及以下几个步骤：

1. **JVM启动参数**：在远程服务器上启动JVM时，需要添加特定的调试参数。这些参数允许JVM在特定的端口上监听调试请求。例如：

    ```sh
    java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 -jar your-application.jar
    ```
2. **JDWP协议**：IDEA使用Java Debug Wire Protocol (JDWP)与远程JVM进行通信。JDWP是Java平台调试架构（JPDA）的一部分，定义了调试器和被调试的JVM之间的通信协议。
3. **Socket连接**：IDEA通过网络套接字（Socket）连接到远程JVM的调试端口。IDEA作为客户端，远程JVM作为服务器，监听来自IDEA的调试请求。
4. **调试会话**：一旦连接建立，IDEA可以发送调试命令（如设置断点、单步执行、查看变量等）到远程JVM。JVM执行这些命令并返回结果。
5. **调试信息传输**：调试信息（如线程状态、变量值、堆栈跟踪等）通过JDWP协议在IDEA和远程JVM之间传输。

‍

‍

### Synchronized 可以在静态代码块上加锁吗？

可以。静态代码块上的锁是类级别的锁，而不是对象级别的锁

‍

‍

### java的内存分配是什么样的，哪些在堆上，哪些在栈上？

在Java中，内存分配主要分为堆内存和栈内存：

1. **堆内存**：

    * 用于存储所有的对象实例和数组。
    * 由**垃圾回收器（Garbage Collector）管理**，负责回收不再使用的对象。
    * 所有通过`new`​关键字创建的对象都存储在堆内存中。
2. **栈内存**：

    * 用于存储方法调用的局部变量和方法调用的上下文（如方法参数、局部变量、返回地址等）。
    * 每个线程都有自己的栈内存，栈内存中的数据随着方法的调用和返回而自动分配和释放。
    * 基本数据类型的局部变量（如`int`​、`float`​等）和对象引用（即指向对象的指针）存储在栈内存中。

‍

以下是一个示例，展示了堆内存和栈内存的使用：

```java
public class MemoryAllocationExample {
    public static void main(String[] args) {
        int localVariable = 10; // 存储在栈内存中
        MyObject obj = new MyObject(); // obj引用存储在栈内存中，MyObject实例存储在堆内存中
        obj.setValue(20); // 修改堆内存中对象的值
    }
}

class MyObject {
    private int value; // 存储在堆内存中

    public void setValue(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }
}
```

在这个示例中：

* ​`localVariable`​是一个局部变量，存储在栈内存中。
* ​`obj`​是一个对象引用，存储在栈内存中。
* ​`new MyObject()`​创建的`MyObject`​实例存储在堆内存中。
* ​`MyObject`​实例的成员变量`value`​也存储在堆内存中。

‍

‍

### JVM 原理

你咋理解的JVM原理 (泛泛谈)

‍

Key

1. 讲标准与实现
2. 跨平台问题
3. JMM内存管理
4. JVM模型
5. 不同的垃圾回收器

‍

> 一段答： jvm是java虚拟机，我们的class文件运行在虚拟机上，通过虚拟机解决了跨平台的问题，jvm中有jmm来管理java内存访问的方式，不同的jvm实现性能关注有差异，现在主流的实现是Hotspot，垃圾回收器是G1，jvm运行时内存中分为...，执行代码时需要执行引擎

‍

‍

## **JVM由哪些部分组成，运行流程是什么？**

* ClassLoader（类加载器）
* Runtime Data Area（运行时数据区，即java内存）
* Execution Engine（执行引擎）
* Native Method Library（本地库接口）

‍

运行流程：

（1）类加载器（ClassLoader）把Java代码转换为字节码

（2）运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行

（3）执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。

垃圾回收器：用于对JVM中的垃圾内容进行回收

‍

‍

## (运行时数据区) 整体内存模型 + 其运行原理

‍

先说JVM 的种类有很多，比如 HotSpot 虚拟机:  Sun/OracleJDK 和 OpenJDK 中的默认 JVM，也是目前使用范围最广的 JVM。

‍

JVM 其实泛指的是 HotSpot 虚拟机

无论是什么类型的虚拟机都必须遵守 Oracle 官方发布的《Java虚拟机规范》

:JVM 的内存布局分为以下几个部分

---

‍

==JVM内存布局==

‍

‍

* 线程独占 : 栈 (每个便签) + PC (指针)

  * 栈

    * ==虚拟机栈==
    * ==本地方法栈==
  * ==程序计数器==
* 共享内存 (线程) : 堆 (一堆零件) + 方法区 (扳手) 

  * ==堆== ( + 运行时常量池 )
  * ==方法区==

‍

5 个内存区域的主要用途如下

‍

‍

### 1.堆 ( + 运行时常量池)

堆（Java Heap） 也叫 Java 堆或者是 GC 堆，它是一个线程共享的内存区域，也是 JVM 中占用内存最大的一块区域，Java 中"所有的对象"都存储在这里。垃圾收集器管理的主要区域

‍

运行时常量池：用于 存放class文件中的字面量（文本字符串、被final修饰的常量、基本数据类型值等）和符号引用（字段、方法描述符）。JDK1.7之后JVM将常量池从方法区中移除，直接放入堆中。

> 《Java虚拟机规范》对 Java 堆的描述是：“所有的对象实例以及数组都应当在堆上分配”。但这在技术日益发展的今天已经有点不那么“准确”了，比如 JIT（Just In Time Compilation，即时编译 ）优化中的**逃逸分析**，使得变量可以直接在栈上被分配。

堆大小的值可通过 -Xms 和 -Xmx 来设置（设置最小值和最大值），当堆超过最大值时就会抛出 OOM（OutOfMemoryError）异常。

‍

‍

当对象或者是变量在方法中被创建之后，其指针可能被线程所引用，而这个对象就被称作 指针逃逸或者是引用逃逸。

比如以下代码中的 sb 对象的逃逸：

```java
public static StringBuffer createString() {
    StringBuffer sb = new StringBuffer();
    sb.append("Java");
    return sb;
}
```

sb 虽然是一个局部变量，但上述代码可以看出，它被直接 return 出去了，因此可能被赋值给了其他变量，并且被完全修改，于是此 sb 就逃逸到了方法外部。

想要 sb 变量不逃逸也很简单，可以改return sb.toString();

> 小贴士：通过逃逸分析可以让变量或者是对象**直接在栈上分配**，从而极大地降低了垃圾回收的次数，以及堆分配对象的压力，进而提高了程序的整体运行效率。

‍

新生代细致划分为 Eden、From Survivor、To Survivor。老年代划分为tentired

‍

‍

### 2.方法区

方法区也称为永久代或是说本地内存的元空间。JDK1.8后使用直接内存的元空间代替了永久代

方法区（Method Area） 也被称为非堆区，用于和“Java 堆”的概念进行区分，它也是线程共享的内存区域，用于存储已经被 JVM 加载的类型信息、常量、静态变量、代码缓存等数据。

‍

‍

> 说到方法区有人可能会联想到 “永久代”，但对于《Java虚拟机规范》来说并没有规定这样一个区域，同样它也只是 HotSpot 中特有的一个概念。这是因为 HotSpot 技术团队把垃圾收集器的分代设计扩展到方法区之后才有的一个概念，可以理解为 HotSpot 技术团队只是用永久代来实现方法区而已，但这会导致一个致命的问题，这样设计更容易造成内存溢出。
>
> 因为永久代有 -XX：MaxPermSize（方法区分配的最大内存）的上限，即使不设置也会有默认的大小。例如，32 位操作系统中的 4GB 内存限制等，并且这样设计导致了部分的方法在不同类型的 Java 虚拟机下的表现也不同，比如 String::intern() 方法。所以在 JDK 1.7 时 HotSpot 虚拟机已经把原本放在永久代的字符串常量池和静态变量等移出了方法区，并且在 JDK 1.8 中完全废弃了永久代的概念。

‍

‍

‍

### 3.程序计数器

我理解的PC, 每个线程都必须有一个私有的

程序计数器（Program Counter Register） 线程独有一块很小的内存区域，保存当前线程所执行字节码的位置，包括正在执行的指令、跳转、分支、循环、异常处理等

‍

‍

### 4.虚拟机栈

虚拟机栈也叫 Java 虚拟机栈（Java Virtual Machine Stack），和程序计数器相同它也是线程独享的，用来描述 Java 方法的执行，在每个方法被执行时就会同步创建一个==栈帧==，用来存储局部变量表、操作栈、动态链接、方法出口等信息。当调用方法时执行入栈，而方法返回时执行出栈。

‍

虚拟机栈由一个个的栈帧组成，每个栈帧包括局部变量表、操作数栈、动态链接、方法出口信息。

* 局部变量表: 存放方法内的局部变量
* 操作数栈：用来执行操作
* 动态链接：用来处理多态的引用
* 返回地址：用来处理返回

‍

‍

### 5.本地方法栈

‍

本地方法栈（Native Method Stacks）与虚拟机栈类似，它是线程独享的，并且作用也和虚拟机栈类似。只不过虚拟机栈是为虚拟机中执行的 Java 方法服务的，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

> 小贴士：需要注意的是《Java虚拟机规范》只规定了有这么几个区域，但没有规定 JVM 的具体实现细节，因此对于不同的 JVM 来说，实现也是不同的。例如，“永久代”是 HotSpot 中的一个概念，而对于 JRockit 来说就没有这个概念。所以很多人说的 JDK 1.8 把永久代转移到了元空间，这其实只是 HotSpot 的实现，而非《Java虚拟机规范》的规定。

‍

‍

‍

‍

## JIT

Java JIT（Just-In-Time）编译器是Java虚拟机（JVM）的一部分，它在程序运行时将字节码（Bytecode）编译为本地机器码，从而提高程序的执行效率。

‍

### 特点

1. **即时编译**：JIT编译器在程序运行时动态地将字节码编译为机器码，而不是在程序启动前进行编译。
2. **性能优化**：JIT编译器可以进行各种优化，如内联、逃逸分析等，以提高程序的执行效率。
3. **热点代码**：JIT编译器会重点优化那些被频繁执行的代码段（热点代码），以最大化性能提升。

‍

### 工作流程

1. **字节码加载**：JVM加载Java类文件并将其转换为字节码。
2. **解释执行**：JVM开始解释执行字节码。
3. **热点检测**：JIT编译器监测到某些方法或代码段被频繁执行时，将其标记为热点代码。
4. **即时编译**：JIT编译器将热点代码编译为本地机器码，并替换原来的字节码。
5. **执行优化后的代码**：JVM执行编译后的本地机器码，从而提高执行效率。

‍

### 优点

* **提高性能**：通过将字节码编译为本地机器码，减少了解释执行的开销。
* **动态优化**：JIT编译器可以根据运行时的实际情况进行优化，适应不同的执行环境。

‍

### 缺点

* **启动时间较长**：由于需要进行即时编译，程序启动时可能会有一定的延迟。
* **内存占用增加**：编译后的本地机器码需要额外的内存空间。

总结来说，Java JIT编译器通过在运行时将字节码编译为本地机器码，显著提高了Java程序的执行效率。

‍

‍

## 写的代码在CPU怎么跑起来的

‍

1. **编译**：Java 源代码（.java 文件）首先被编译成字节码（.class 文件）。这个过程由 Java 编译器（javac）完成。
2. **类加载**：Java 虚拟机（JVM）启动时，会通过类加载器（ClassLoader）将字节码加载到内存中。
3. **字节码解释**：JVM 内部有一个解释器（Interpreter），它逐行解释字节码并将其转换为机器码，供 CPU 执行。
4. **即时编译（JIT）** ：为了提高性能，JVM 还包含一个即时编译器（Just-In-Time Compiler, JIT）。JIT 会将热点代码（频繁执行的代码）编译成本地机器码，以提高执行效率。
5. **执行**：最终，编译后的机器码在 CPU 上执行。

‍

以下是一个简单的示意图，展示了 Java 代码从编写到在 CPU 上执行的过程：

```plaintext
Java 源代码 (.java)  -->  编译 (javac)  -->  字节码 (.class)  -->  类加载 (ClassLoader)  -->  字节码解释 (Interpreter)  -->  即时编译 (JIT)  -->  机器码  -->  CPU 执行
```

这个过程确保了 Java 代码可以在不同的平台上运行，而无需修改源代码。

‍

‍

## 栈帧是什么

栈帧是函数调用时在栈上分配的一块内存区域，用于存储函数的局部变量、参数、返回地址和其他信息。每次函数调用都会创建一个新的栈帧，函数返回时栈帧会被销毁。

‍

主要组成部分

1. **返回地址**：调用函数后，程序需要知道返回到哪里继续执行。
2. **参数**：传递给函数的参数。
3. **局部变量**：函数内部定义的变量。
4. **保存的寄存器**：保存调用者的寄存器状态，以便函数返回时恢复。

栈帧的结构因编译器和处理器架构而异，但基本原理相同。以下是一个简化的栈帧示意图：

```plaintext
+-----------------+
| 返回地址        |
+-----------------+
| 参数1           |
+-----------------+
| 参数2           |
+-----------------+
| ...             |
+-----------------+
| 局部变量1       |
+-----------------+
| 局部变量2       |
+-----------------+
| ...             |
+-----------------+
| 保存的寄存器状态|
+-----------------+
```

这个结构确保了 函数调用和返回时能够正确管理和恢复程序的执行状态。

‍

‍

## 弱引用啥时候会被回收

1. **没有强引用**：当一个对象只有弱引用指向它时，垃圾回收器会认为该对象是可回收的。
2. **垃圾回收**：在下一次垃圾回收时，垃圾回收器会回收所有只有弱引用指向的对象。

‍

弱引用的主要特点是它不会阻止垃圾回收器回收对象，因此在内存不足时，这些对象会被优先回收。

‍

‍

‍

## java是编译型语言还是解释型语言？.java编译完之后是编译模式还是解释？为什么java要这样设计？为什么不直接设计成解释型语言呢？（因为这样就得每个系统构建单独的解释器）

Java 是一种编译型和解释型相结合的语言。

‍

### 编译和解释过程

1. **编译**：Java 源代码（.java 文件）首先被编译器（javac）编译成字节码（.class 文件）。字节码是一种中间表示形式，与具体的硬件平台无关。
2. **解释**：编译后的字节码由 Java 虚拟机（JVM）解释执行。JVM 是一个解释器，它将字节码逐行解释成机器码并执行。

‍

### 设计原因

1. **跨平台性**：Java 设计成编译和解释相结合的模式，主要是为了实现“一次编写，到处运行”的跨平台特性。字节码与平台无关，可以在任何安装了 JVM 的系统上运行。
2. **性能优化**：JVM 可以在运行时进行各种优化，如即时编译（JIT），将热点代码编译成机器码，提高执行效率。
3. **安全性**：字节码可以在 JVM 中运行，JVM 提供了沙箱机制，可以有效地隔离和保护系统资源，增强安全性。

‍

### 为什么不直接设计成解释型语言

1. **性能**：纯解释型语言的执行效率较低，因为每次执行都需要逐行解释代码。Java 通过编译成字节码并结合 JIT 编译，可以在保持跨平台性的同时提高性能。
2. **优化**：编译成字节码后，JVM 可以在运行时进行各种优化，提高代码执行效率。
3. **开发效率**：编译型语言可以在编译时发现语法和类型错误，提高开发效率和代码质量。

总之，Java 通过编译和解释相结合的设计，实现了跨平台性、性能优化和安全性等多方面的平衡。

‍

‍

‍

## jvm - string都在元空间吗？

字符串并不都在元空间（Metaspace）中

‍

### 1. 字符串常量池

字符串常量池（String Constant Pool）是一个特殊的内存区域，用于存储字符串字面量和通过 `String.intern()`​ 方法创建的字符串。自 Java 7 起，字符串常量池从永久代（PermGen）移到了**堆**（Heap）中。

‍

### 2. 堆内存

**大多数字符串对象是在堆内存中分配的**。每当你使用 `new String()`​ 创建一个新的字符串对象时，它会在堆内存中分配。

‍

### 3. 元空间

元空间（Metaspace）是 Java 8 之后取代永久代的内存区域，用于存储类的元数据（如类的结构、方法、字段等）。字符串对象本身并不存储在元空间中，但类的元数据（如 `java.lang.String`​ 类的定义）会存储在元空间中。

‍

‍

‍

# 大块

‍

### 程序计数器

‍

#### 程序计数器为什么私有

程序计数器主要有下面两个作用：

1. **字节码解释器**通过改变程序计数器来依次**读取指令**，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

‍

需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。

所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置, 就是保证其正常功能的进行**

‍

‍

#### 虚拟机栈和本地方法栈为什么是私有的?

* **虚拟机栈：**  每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
* **本地方法栈：**  和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**  在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

‍

‍

## 类加载

‍

类的生命周期会经历以下 7 个阶段：

1. **加载** （Loading）
2. **连接** （Linking）

    1. 验证 （Verification）
    2. 准备 （Preparation）
    3. 解析 （Resolution）
3. **初始化**（Initialization）

    ---
4. 使用阶段（Using）
5. 卸载阶段（Unloading）

‍

平常所说的 JVM 类加载通常指的就是前五个阶段：加载、验证、准备、解析、初始化等

‍

> * 加载：第一步通过全类名获取定义此类的二进制字节流。第二步将字节流所代表的静态存储结构转换为方法区的数据结构。第二部在内存中生成一个代表该类的Class对象，作为方法区这些数据访问的入口。加载阶段需要用到类加载器。
> * 验证：校验一下.class文件是否正确，比如文件格式、语义方面、符号方面等。
> * 准备：主要为类变量分配内存并设置初始值（数据类型的默认值而不是被赋与的默认值）。类变量主要是在方法区中操作。其中类变量会分配内存，而实例变量不会，实例变量随着对象实例化分配到堆内存中。
> * 解析：将常量池中符号引用转化为直接引用。主要针对类、接口、字段、方法、方法类型等的引用。
> * 初始化：主要为类的静态变量赋值，可以通过类变量指定初始值或者静态代码块指定初始值。（类的初始化触发条件：new一个类/调用类的静态变量或方法/反射/初始化类的子类）。

‍

‍

### 1. 加载阶段

此阶段用于查到相应的类（通过类名进行查找）并将此类的字节流转换为方法区运行时的数据结构，然后再在内存中生成一个能代表此类的 `java.lang.Class`​ 对象，作为其他数据访问的入口。

> 小贴士：需要注意的是加载阶段和连接阶段的部分动作有可能是**交叉执行**的，比如一部分字节码文件格式的验证，在加载阶段还未完成时就已经开始验证了。

‍

---

连接

---

### 2. 验证阶段

校验 + 拆包

此步骤主要是为了验证字节码的安全性，如果不做安全校验的话可能会载入非安全或有错误的字节码，从而导致系统崩溃，它是 JVM 自我保护的一项重要举措。

验证的主要动作大概有以下几个：

* **文件格式校验**包括常量池中的常量类型、Class 文件的各个部分是否被删除或被追加了其他信息等； 检查类文件的魔数 0xCAFEBABE 以确保文件格式正确
* **元数据校验**包括父类正确性校验（检查父类是否有被 final 修饰）、抽象类校验等；
* **字节码校验**，此步骤最为关键和复杂，主要用于校验程序中的语义是否合法且符合逻辑；
* **符号引用校验**，对类自身以外比如常量池中的各种符号引用的信息进行匹配性校验。

‍

‍

### 3. 准备阶段

初始化 + 分配内存

此阶段是用来**初始化**并为类中定义的**静态变量分配内存**的，这些**静态变量会被分配到方法区**上 -> HotSpot 虚拟机在 JDK 1.7 之前都在方法区，而 JDK 1.8 之后此变量会随着类对象一起存放到 Java 堆中。

‍

‍

### 4. 解析阶段

翻译 + 连接

此阶段主要是用来解析类、接口、字段及方法的，解析时会把符号引用替换成直接引用。

所谓的符号引用是指以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可；而直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。

符号引用和直接引用有一个重要的区别：使用符号引用时被引用的目标不一定已经加载到内存中；而**使用直接引用时，引用的目标必定已经存在虚拟机的内存中了**。

‍

‍

### 5. 初始化

初始化阶段 JVM 就正式开始执行类中编写的 Java 业务代码了。到这一步骤之后，类的加载过程就算正式完成了。

‍

‍

‍

### 加载 class 文件原理

‍

关键点：

1. 类加载器
2. 魔数
3. 元空间

负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。

‍

‍

#### **魔数 0xCAFEBABE**

* Class文件开头的四个字节的无符号整数称为魔数(Magic Number)
* 魔数是Class文件的标识。值是固定的，为**0xCAFEBABE**
* 如果一个Class文件的头四个字节不是0xCAFEBABE，虚拟机在进行文件校验的时候会报错。使用魔数而不是扩展名来识别Class文件，主要是基于安全方面的考虑，因为文件扩展名可以随意更改。

‍

‍

#### 类加载器

分为四种：前三种为虚拟机自带的加载器。

* 启动类加载器（Bootstrap）C++

  负责加载$JAVA_HOME中jre/lib/**rt.jar**里所有的class，由C++实现，不是ClassLoader子类

  也叫系统类加载器，负责加载**classpath**中指定的jar包及目录中class
* 扩展类加载器（Extension）Java

  负责加载java平台中**扩展功能**的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包
* 应用程序类加载器（AppClassLoader）Java
* 用户自定义加载器  Java.lang.ClassLoader的子类，用户可以定制类的加载方式

‍

简洁

* BootStrap ClassLoader：最顶层加载器，主要加载核心类库。
* Extention ClassLoader：扩展的类加载器，加载扩展包的类库。
* App classLoader：加载当前应用的根目录下所有类。
* 自定义类加载器，继承ClassLoader。

‍

‍

#### 类加载器工作过程

* 1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
* 2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
* 3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；
* 4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载
* 5、如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException

其实这就是所谓的**双亲委派模型**。简单来说：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把**请求委托给父加载器去完成，依次向上**。

‍

好处：**防止内存中出现多份同样的字节码**(安全性角度)  
比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。

‍

‍

### 类加载的双亲委派机制

‍

‍

‍

## 垃圾回收

‍

### 啥时候Full GC

1. **老年代（Old Generation）空间不足**：当老年代的内存空间不足以容纳新对象或晋升的对象时，会触发Full GC。
2. **永久代（PermGen）或元空间（Metaspace）空间不足**：在Java 8之前，永久代空间不足会触发Full GC。在Java 8及之后，元空间不足也会触发Full GC。
3. **调用System.gc()** ：显式调用`System.gc()`​方法会建议JVM进行Full GC，尽管JVM可以选择忽略这个建议。
4. **老年代对象晋升失败**：当新生代对象晋升到老年代时，如果老年代没有足够的空间容纳这些对象，会触发Full GC。
5. **大对象分配失败**：当需要分配一个大对象且老年代没有足够的连续空间时，会触发Full GC。

‍

‍

### GC触发类型

* young GC：当新生代中的eden区内存满时会触发young GC，GC过后新生代一部分存活对象可能会升级到老年代中，导致老年代占用量上升。
* full GC：每次触发young GC时会判断GC后升级到老年代的对象占用内存是否大于老年代剩余的内存，如果大于，那么就不触发young GC转而触发full GC。如果老年代或者持久代被写满时也会触发full GC。调用System.gc()方法时也会触发full GC（一般GC由虚拟机决定，不会手动调用，即使调用了也不一定会触发）

‍

‍

### 类引用类型

1. 强引用：常用的普通对象的引用，**当JVM内存不足时会抛出OutOfMemoryError错误使程序停止**，也不会去回收强引用的对象。**被赋值为null**后可以被垃圾收集器回收。
2. 软引用：通过SoftReference类实现，当JVM**内存不足时，才会去回收软引用的对象**，以防止出现OutOfMemoryError错误，可以调用ReferenceQueue的poll()方法来检查指定对象是否被回收，软引用可以用于内存不足的缓存中。
3. 弱引用：通过WeakReference类实现，当垃圾收集器发现了弱引用的对象，**不管当前内存空间是否足够，都会回收对象**，因为垃圾回收器是一个优先级很低的线程，因此弱引用可能会存活很长一段时间，弱引用被回收时，会把弱引用假如到与之关联的引用队列ReferenceQueue中。
4. 虚引用：通过PhantomReference类实现，我们无法通过虚引用访问对象，垃圾收集器随时可以回收它。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。可以通过判断是否加入了引用对象来判断对象是否被回收。

‍

‍

## 垃圾回收算法

垃圾回收器首先要做的就是，判断一个对象是存活状态还是死亡状态，死亡的对象将会被标识为垃圾数据并等待收集器进行清除。

判断一个对象是否为死亡状态的常用算法有两个：引用计数器算法和可达性分析算法。

‍

### 死亡确认

(找到垃圾才能进行)

‍

#### **引用计数算法（Reference Counting）**

属于垃圾收集器最早的实现算法了，它是指在创建对象时关联一个与之相对应的计数器，当此对象被使用时加 1，相反销毁时 -1。当此计数器为 0 时，则表示此对象未使用，可以被垃圾收集器回收。

‍

优点是垃圾回收比较及时，实时性比较高，只要对象计数器为 0，则可以直接进行回收操作

缺点是无法解决循环引用的问题

‍

‍

‍

#### **可达性分析算法（Reachability Analysis）**

是目前商业系统中所采用的判断对象死亡的常用算法，它是指从对象的起点（GC Roots）开始向下搜索，如果对象到 GC Roots 没有任何引用链相连时，也就是说此对象到 GC Roots 不可达时，则表示此对象可以被垃圾回收器所回收

‍

‍

**GC Roots**

在 Java 中可以作为 GC Roots 的对象，主要包含以下几个：

* 所有被**同步锁**持有的对象，比如被 synchronize 持有的对象

  > 这些对象在多线程环境中被锁定，确保它们在同步块或方法执行期间不会被垃圾回收
  >
* **字符串常量池**里的引用（String Table）

  > 字符串常量池中的字符串是全局共享的，JVM 会确保这些字符串在整个程序运行期间都存在，因此它们不会被垃圾回收。
  >
* 类型为引用类型的静态变量；

  > 静态变量属于类本身，而不是类的实例。只要类被加载，静态变量就会存在，因此它们不会被垃圾回收。
  >
* **栈**中的对象

  * 虚拟机栈中引用对象；

    > 方法执行时，局部变量表中的引用对象是活动的，JVM 会确保这些对象在方法执行期间不会被垃圾回收。
    >
  * 本地方法栈中的引用对象。

    > 本地方法栈中的引用对象是本地方法调用时使用的，JVM 会确保这些对象在本地方法执行期间不会被垃圾回收。
    >

‍

主要就是不会被垃圾回收的玩意

‍

‍

‍

#### 死亡对象判断

‍

当使用可达性分析判断一个对象不可达时，并不会直接标识这个对象为死亡状态，而是先将它标记为“待死亡”状态再进行一次校验。校验的内容就是此对象**是否重写了 finalize() 方法**

如果该对象重写了 finalize() 方法，那么这个对象将会被存入到 F-Queue 队列中，等待 JVM 的 Finalizer 线程去执行重写的 finalize() 方法，在这个方法中如果此对象将自己赋值给某个类变量时，则表示此对象已经被引用了。因此不能被标识为死亡状态，其他情况则会被标识为死亡状态。

‍

```java
public class FinalizeTest {
    // 需要状态判断的对象
    public static FinalizeTest Hook = null;

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("执行了 finalize 方法");
        Fi nalizeTest.Hook = this;
    }

    public static void main(String[] args) throws InterruptedException {
        Hook = new FinalizeTest();
        // 卸载对象，第一次执行 finalize()
        Hook = null;
        System.gc();
        Thread.sleep(500); // 等待 finalize() 执行
        if (Hook != null) {
            System.out.println("存活状态");
        } else {
            System.out.println("死亡状态");
        }
        // 卸载对象，与上一次代码完全相同
        Hook = null;
        System.gc();
        Thread.sleep(500); // 等待 finalize() 执行
        if (Hook != null) {
            System.out.println("存活状态");
        } else {
            System.out.println("死亡状态");
        }
    }
}
```

上述代码的执行结果为：

```text
执行了 finalize 方法
存活状态
死亡状态
```

‍

从结果可以看出，卸载了两次对象，第一次执行了 finalize() 方法，成功地把自己从待死亡状态拉了回来；而第二次同样的代码却没有执行 finalize() 方法，从而被确认为了死亡状态，这是因为**任何对象的 finalize() 方法都只会被系统调用一次**。

虽然可以从 finalize() 方法中把自己从死亡状态“拯救”出来，但是不建议这样做，因为所有对象的 finalize() 方法只会执行一次。因此同样的代码可能产生的结果是不同的，这样就给程序的执行带来了很大的不确定性。

‍

‍

‍

‍

### 垃圾回收算法

(狭义)

当确定了对象的状态之后（存活还是死亡）接下来就是进行垃圾回收了，垃圾回收的常见算法有以下几个：

* 标记-清除算法；
* 标记-复制算法；
* 标记-整理算法。

‍

‍

#### **标记-清除**

(搜寻并歼灭 Search and destroy)

 **（Mark-Sweep）**

算法属于最早的垃圾回收算法，它是由标记阶段和清除阶段构成的。标记阶段会给所有的存活对象做上标记，而清除阶段会把没有被标记的死亡对象进行回收。而标记的判断方法就是前面讲的引用计数算法和可达性分析算法。 会产生内存空间的碎片化问题

‍

#### **标记-复制**

(两半)

是标记-清除算法的一个升级，使用它可以有效地解决内存碎片化的问题。它是指将内存分为大小相同的两块区域，每次只使用其中的一块区域，这样在进行垃圾回收时就可以直接将存活的东西复制到新的内存上，然后再把另一块内存全部清理掉。这样就不会产生内存碎片的问题了

‍

#### **标记-整理**

(紧凑

诞生晚于标记-清除算法和标记-复制算法，它也是由两个阶段组成的：标记阶段和整理阶段。

其中标记阶段和标记-清除算法的标记阶段一样，不同的是后面的一个阶段，标记-整理算法的后一个阶段不是直接对内存进行清除，而是把所有存活的对象移动到内存的一端紧密排列好，然后把另一端的所有死亡对象全部清除 (将所有存活的对象往左端空闲空间移动，并更新对应指针)

‍

‍

#### 分代收集模型

目前商用虚拟机的垃圾收集器都是基于分代收集的理论进行设计的

指将**不同“年龄”** 的数据**分配到不同的内存区域**中进行存储，所谓的“年龄”指的是**经历过垃圾收集的次数**。一般(JAVA堆)分为老年代、新生代和永久代。

这样就可以把那些朝生暮死的对象集中分配到一起，把不容易消亡的对象分配到一起，对于不容易死亡的对象我们就可以设置较短的垃圾收集频率，这样就能消耗更少的资源来实现更理想的功能了

‍

通常情况下分代收集算法会分为两个区域：新生代（Young Generation）和老年代（Old Generation），其中新生代用于存储刚刚创建的对象，这个区域内的对象存活率不高，而对于经过了一定次数的 GC 之后还存活下来的对象，就可以成功晋级到老生代了。

> 说一下对于不同的实现有表述上的区别, 各自的具体结构也有不同

‍

可以根据不同代采用不同收集算法，提高了垃圾回收效率:

* 老年代特点是每次垃圾收集时只有少量对象被回收，所以适合采用**标记整理**算法
* 新生代特点是每次垃圾回收时都有大量的对象需要被回收，所以适合采用**复制算法**，每次只需要复制少量存活对象

‍

### 讲一下新生代、老年代、永久代的区别？

**新生代**主要用来存放新生的对象。新生代又被进一步划分为 **Eden区** 和 **Survivor区**，Survivor 区由 **From Survivor** 和 **To Survivor** 组成

**老年代**主要存放应用中生命周期长的内存对象。

**永久代**指的是永久保存区域。主要存放Class和Meta（元数据）的信息。在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（**元空间**）的区域。元空间和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。

‍

‍

## 垃圾回收器

‍

### 哪些?

用过哪些垃圾回收器？它们有什么区别？(最简单)

‍

先讲比较常用的虚拟机是 OracleJDK 中自带的 HotSpot 虚拟机, 然后介绍 HotSpot 中使用的垃圾收集器主要包括 7 个：

**Serial、ParNew、Parallel Scavenge、|| Serial Old、Parallel Old、CMS 和 G1（Garbage First）收集器**

‍

‍

#### **Serial 收集器**

(默认新生代)

最早期的垃圾收集器，也是 JDK 1.3 版本之前唯一的垃圾收集器。

单线程运行的垃圾收集器，其单线程是指在进行垃圾回收时所有的工作线程必须暂停 STW ，直到垃圾回收结束为止.

简单和高效，并且本身的运行对内存要求不高，因此它在客户端模式下使用的比较多

‍

‍

#### **ParNew 收集器**

(默认新生代)

Serial 收集器的多线程并行版本

‍

‍

#### **Parallel Scavenge 收集器**

(默认新生代)

和 ParNew 收集器类似，它也是一个并行运行的垃圾回收器；

不同的是，该收集器关注的侧重点是**实现一个可以控制的吞吐量**。

而这个吞吐量计算的也很奇怪，它的计算公式是：用户运行代码的时间 / （用户运行代码的时间 + 垃圾回收执行的时间）。比如用户运行的时间是 8 分钟，垃圾回收运行的时间是 2 分钟，那么吞吐量就是 80%。Parallel Scavenge 收集器追求的目标就是将这个吞吐量的值，控制在一定的范围内。

‍

Parallel Scavenge 收集器有两个重要的参数：

* -XX:MaxGCPauseMillis 参数：它是用来控制垃圾回收的最大停顿时间；
* -XX:GCTimeRatio 参数：它是用来直接设置吞吐量的值的。

‍

‍

#### **Serial Old 收集器**

Serial GC 老年代版本

‍

#### Parallel Old 收集器

Parallel Scavenge GC 老年代版本

‍

‍

#### **CMS（Concurrent Mark Sweep）收集器**

(默认老年代)

与以吞吐量为目标的 Parallel Scavenge 收集器不同，它强调的是提供**最短的停顿时间**，因此可能会**牺牲一定的吞吐量**

主要应用在 Java Web 项目中，以此来提高用户的交互体验。

‍

‍

##### 具体执行流程: Why 停顿时间短

> 加分项

CMS 收集器是基于**标记-清除**算法实现的 (最呆的一个)

‍

整个过程可以分为四个阶段：

* 初始标记（CMS initial mark）
* 并发标记（CMS concurrent mark）
* 重新标记（CMS remark）
* 并发清除（CMS concurrent sweep）

**初始标记**阶段的执行时间很短，它只是标记一下 GC Roots 的关联对象；

**并发标记**​阶段是从 GC Roots 关联的对象进行遍历判断并标识死亡对象，这个过程比较慢，但不需要停止用户线程，用户的线程可以和垃圾收集线程并发执行；

**重新标记**阶段则是为了判断并标记，刚刚并发阶段用户**继续运行**的那一部分对象，所以此阶段的执行时间也比较短；(回首掏)

**并发清除**阶段，也就是清除上面标记的死亡对象，由于 CMS 使用的是**标记-清除**算法，而非**标记-整理**算法，因此无须移动存活的对象，这个阶段垃圾收集线程也可以和用户线程并发执行。

CMS 的整个执行过程中只有执行时间很短的==初始标记==和==重新标记==需要 Stop The World（全局停顿）的

‍

**执行过程**

```java
用户线程组->     |               | 用户线程组->  |                | 用户线程组->      |
               |    STW初始标记->   | 并发标记->   |   STW重新标记->    | 并发清理->        |
```

‍

‍

对于**并发标记**而言，必须解决**漏标问题(我标记完了, 结果用户修改了)** ，也就是要记录标记过程中的变化。

有两种解决方法：

1. Incremental Update 增量更新法，CMS 垃圾回收器采用

    * 思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍
2. Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用

    * 思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理
    * 新加对象会被记录
    * 被删除引用关系的对象也被记录

‍

‍

##### 碎片处理 : **标记-清除的处理方案**

因为 CMS 是一款基于标记清除算法实现的垃圾收集器，因此会在收集时产生**大量的空间碎片**，为了解决这个问题，CMS 收集器提供了一个 `-XX:+UseCMS-CompactAtFullCollection`​ 的参数（默认是开启的，此参数从 JDK9 开始废弃），用于在 CMS 收集器**进行 Full GC 时开启内存碎片的合并和整理。**

但又因为碎片整理的过程必须移动存活的对象，所以它和用户线程是无法并发执行的，为了解决这个问题 CMS 收集器又提供了另外一个参数`<span> </span>-XX:CMSFullGCsBefore-Compaction`​，用于规定多少次（根据此参数的值决定）之后再进行一次碎片整理。

‍

‍

‍

‍

#### **Garbage First（简称 G1）收集器**

(整堆收集 - 新 + 老) 混合型

是历史发展的产物，也是一款更先进的垃圾收集器，主要面向服务端应用的垃圾收集器。

将内存划分为多个 **Region 分区**，回收时则**以分区为单位**进行回收，这样它就可以用相对较少的时间**优先回收包含垃圾最多区块**。

从 JDK 9 之后也成了官方默认的垃圾收集器

‍

‍

‍

## OOM综合

当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error（注：非exception，因为这个问题已经严重到不足以被应用处理）

> 可以对照我的项目进行处理: 业务场景下发生了什么, 做了什么, 取得了什么结果.

‍

‍

### 为什么

原因不外乎有两点：

* 1）分配的少了：比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。
* 2）应用用的太多，并且用完没释放，浪费了。此时就会造成内存泄露或者内存溢出。

‍

**内存泄露**：申请使用完的**内存没有释放**，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。

**内存溢出**：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。

‍

‍

### OOM类型

‍

**JVM内存模型**

‍

按照JVM规范，JAVA虚拟机在运行时会管理以下的内存区域：

* 程序计数器：当前线程执行的字节码的行号指示器，线程私有
* JAVA虚拟机栈：Java方法执行的内存模型，每个Java方法的执行对应着一个栈帧的进栈和出栈的操作。
* 本地方法栈：类似“ JAVA虚拟机栈 ”，但是为native方法的运行提供内存环境。
* JAVA堆：对象内存分配的地方，内存垃圾回收的主要区域，所有线程共享。可分为新生代，老生代。
* 方法区：用于存储已经被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Hotspot中的“永久代”。
* 运行时常量池：方法区的一部分，存储常量信息，如各种字面量、符号引用等。
* **直接内存**：并不是JVM运行时数据区的一部分， 可直接访问的内存， 比如NIO会用到这部分。

‍

按照JVM规范，除了程序计数器不会抛出OOM外，其他各个内存区域都可能会抛出OOM

‍

最常见的OOM情况有以下三种：

**堆内存OOM, 永久代OOM, SOF**

* java.lang.OutOfMemoryError: Java heap space ------>java**堆内存溢出**，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数 ==-Xms, -Xmx== 等修改。
* java.lang.OutOfMemoryError: PermGen space ------>java永久代溢出，即**方法区溢出了**，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似 ==-XX:PermSize=64m -XX:MaxPermSize=256m== 的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。
* java.lang.StackOverflowError ------> 不会抛OOM error，但也是比较常见的Java内存溢出: JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数 ==-Xss== 来设置栈的大小。

‍

‍

## heapdump分析

转储堆内存镜像来进行故障排查

‍

要dump(转储)堆的内存镜像，可以采用如下两种方式：

* 设置JVM参数-XX:+HeapDumpOnOutOfMemoryError，设定当发生OOM时自动dump出堆信息 (JDK5以上版本)
* 使用JDK自带的jmap命令。"jmap -dump:format=b,file=heap.bin " 其中pid可以通过jps获取。

‍

dump堆内存信息后，需要对dump出的文件进行分析，从而找到OOM的原因。常用的工具有：

* mat: eclipse memory analyzer, 基于 eclipse RCP 的内存分析工具。详细信息参见：[http://www.eclipse.org/mat/](http://www.eclipse.org/mat/%EF%BC%8C%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E3%80%82) ，推荐使用
* jhat：JDK自带的java heap analyze tool，可以将堆中的对象以html的形式显示出来，包括对象的数量，大小等等，并支持对象查询语言OQL，分析相关的应用后，可以通过http://localhost:7000来访问分析结果。不推荐使用，因为在实际的排查过程中，一般是先在生产环境 dump出文件来，然后拉到自己的开发机器上分析，所以，不如采用高级的分析工具比如前面的mat来的高效。

采用mat分析的例子

‍

注意：因为JVM规范没有对dump出的文件的格式进行定义，所以不同的虚拟机产生的dump文件并不是一样的。在分析时，需要针对不同的虚拟机的输出采用不同的分析工具（当然，有的工具可以兼容多个虚拟机的格式）。IBM HeapAnalyzer也是分析heap的一个常用的工具。

‍

‍

### jmap

​`jmap`​ 是 JDK 提供的一个命令行工具，用于生成 Java 虚拟机 (JVM) 的内存映像（heap dump）和查看内存使用情况。它可以帮助开发者分析内存泄漏、对象分布等问题。

‍

常用的 `jmap`​ 命令

1. **生成堆转储文件**

    ```sh
    jmap -dump:format=b,file=heapdump.hprof <pid>
    ```

    这条命令会生成一个堆转储文件 `heapdump.hprof`​，其中 `<pid>`​ 是目标 JVM 进程的进程 ID。
2. **查看堆内存摘要**

    ```sh
    jmap -heap <pid>
    ```

    这条命令会输出堆内存的使用情况摘要，包括堆配置、使用情况和垃圾收集器信息。
3. **查看对象的直方图**

    ```sh
    jmap -histo <pid>
    ```

    这条命令会输出 JVM 中所有对象的直方图，包括对象的数量和占用的内存。
4. **查看永久代（Metaspace）信息**

    ```sh
    jmap -permstat <pid>
    ```

    这条命令会输出永久代（或 Metaspace）的类加载器信息和类的内存使用情况。

‍

‍

# 高级

‍

## 逃逸分析

通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。

使用逃逸分析，编译器可以对代码做如下优化：

1. 同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
2. 将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。
3. 分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

‍

## 类加载器

启动类加载器：用C++语言实现，是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib路径下的核心类库，无法被Java程序直接引用  
扩展类加载器：用Java语言实现，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用  
系统类加载器：用Java语言实现，它负责加载系统类路径ClassPath指定路径下的类库，开发者可以直接使用

‍

## JVM调优

前提：在进行GC优化之前，需要确认项目的架构和代码等已经没有优化空间

目的：优化JVM垃圾收集性能从而增大吞吐量或减少停顿时间，让应用在某个业务场景上发挥最大的价值。吞吐量是指应用程序线程用时占程序总用时的比例。暂停时间是应用程序线程让与GC线程执行而完全暂停的时间段

对于交互性web应用来说，一般都是减少停顿时间，所以有以下方法：

1. 如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大
2. 让大对象进入年老代。可以使用参数-XX:PetenureSizeThreshold 设置大对象直接进入年老代的阈值。当对象的大小超过这个值时，将直接在年老代分配
3. 设置对象进入年老代的年龄。如果对象每经过一次 GC 依然存活，则年龄再加 1。当对象年龄达到阈值时，就移入年老代，成为老年对象
4. 使用关注系统停顿的 CMS 回收器

基础：[https://www.ibm.com/developerworks/cn/java/j-lo-jvm-optimize-experience/index.html](https://www.ibm.com/developerworks/cn/java/j-lo-jvm-optimize-experience/index.html)

案例：[https://www.wangtianyi.top/blog/2018/07/27/jvmdiao-you-ru-men-er-shi-zhan-diao-you-parallelshou-ji-qi/](https://www.wangtianyi.top/blog/2018/07/27/jvmdiao-you-ru-men-er-shi-zhan-diao-you-parallelshou-ji-qi/)

‍

‍

# Temp

‍

### 运行流程是

运行流程：

（1）类加载器（ClassLoader）把Java代码转换为字节码

（2）运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行

（3）执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。

‍

‍

### 程序计数器

线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。

 java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。

 那么现在有一个问题就是，当前处理器如何能够知道，对于这个被挂起的线程，它上一次执行到了哪里？那么这时就需要从程序计数器中来回去到当前的这个线程他上一次执行的行号，然后接着继续向下执行。

 程序计数器是JVM规范中唯一一个没有规定出现OOM的区域，所以这个空间也不会进行GC。

‍

‍

### Java堆吗

> **面试官**：你能给我详细的介绍Java堆吗?
>
> **候选人:**
>
> 好的~
>
> Java中的堆术语线程共享的区域。主要用来保存**对象实例，数组**等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。
>
>  在JAVA8中堆内会存在年轻代、老年代
>
>  1）Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。
>
>  2）Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区。
>
> **面试官**：能不能解释一下方法区？
>
> **候选人:**
>
> 好的~
>
> 与虚拟机栈类似。本地方法栈是为虚拟机**执行本地方法时提供服务的**。不需要进行GC。本地方法一般是由其他语言编写。
>
> **面试官**：你听过直接内存吗？
>
> **候选人:**
>
> 嗯~~
>
> 它又叫做**堆外内存**，**线程共享的区域**，在 Java 8 之前有个**永久代**的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，**主要存储类的信息，常量，静态变量**，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果大量动态生成类（将类信息放入永久代），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。
>
>  所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能。
>
> **面试官**：什么是虚拟机栈
>
> **候选人:**
>
> 虚拟机栈是描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建**栈桢**。保存执行方法时的**局部变量、动态连接信息、方法返回地址信息**等等。方法开始执行的时候会进栈，方法执行完会出栈【相当于清空了数据】，所以这块区域**不需要进行 GC**。
>
> **面试官**：能说一下堆栈的区别是什么吗？
>
> **候选人:**
>
> 嗯，好的，有这几个区别
>
> 第一，栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。
>
> 第二、栈内存是线程私有的，而堆内存是线程共有的。
>
> 第三、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。
>
> 栈空间不足：java.lang.StackOverFlowError。
>
> 堆空间不足：java.lang.OutOfMemoryError。

‍

‍

为了避免方法区出现OOM，所以在java8中将堆上的方法区【永久代】给移动到了本地内存上，重新开辟了一块空间，叫做**元空间**。那么现在就可以避免掉OOM的出现了

‍

​![image](assets/image-20241116233449-nwqeuce.png)​

‍

##### 元空间(MetaSpace)介绍

 在 HotSpot JVM 中，永久代（ ≈ 方法区）中用于存放类和方法的元数据以及常量池，比如Class 和 Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。

 永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即OutOfMemoryError，为此不得不对虚拟机做调优。

 那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？

官网给出了解释：[http://openjdk.java.net/jeps/122](http://openjdk.java.net/jeps/122)

```text
This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.

移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。
```

1）由于 PermGen 内存经常会溢出，引发OutOfMemoryError，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM。

2）移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。

 准确来说，Perm 区中的字符串常量池被移到了堆内存中是在 Java7 之后，Java 8 时，PermGen 被元空间代替，其他内容比如**类元信息、字段、静态属性、方法、常量**等都移动到元空间区。比如 java/lang/Object 类元信息、静态属性 System.out、整型常量等。

 元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。

‍

‍

‍

### 虚拟机栈

Java Virtual machine Stacks (java 虚拟机栈)

* 每个线程运行时所需要的内存，称为虚拟机栈，先进后出
* 每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存
* 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

1. 垃圾回收是否涉及栈内存？  
    垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放
2. 栈内存分配越大越好吗？  
    未必，默认的栈内存通常为1024k  
    栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半
3. 方法内的局部变量是否线程安全？

    * 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的
    * 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全(对外有交互, 传参和返回都会造成不安全)

1、堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。  
2、方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。  
3、栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。  
4、本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。  
5、程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。

‍

‍

### 方法区

* 各个线程共享的内存区域
* 主要存储类的信息、运行时常量池
* 虚拟机启动的时候创建，关闭虚拟机时释放
* 如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace

‍

### 常量池

可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息

查看字节码结构（类的基本信息、常量池、方法定义）`javap -v xx.class`​

‍

找到类对应的class文件存放目录，执行命令：`javap -v Application.class`​ 查看字节码结构

下图，左侧是main方法的指令信息，右侧constant pool 是常量池

main方法按照指令执行的时候，需要到常量池中查表翻译找到具体的类和方法地址去执行

​![image](assets/image-20241116233750-fcjqsf2.png)​

‍

‍

#### 运行时常量池

常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址

‍

### 直接内存

不受 JVM 内存回收管理，是虚拟机的系统内存，常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理

‍

可以发现，使用传统的IO的时间要比NIO操作的时间长了很多了，也就说NIO的读性能更好。

这个是跟我们的JVM的直接内存是有一定关系，如下图，是传统阻塞IO的数据传输流程

​![image](assets/image-20241116234020-7teve8n.png)​

‍

下图是NIO传输数据的流程，在这个里面主要使用到了一个直接内存，不需要在堆中开辟空间进行数据的拷贝，jvm可以直接操作直接内存，从而使数据读写传输更快

​![image](assets/image-20241116234036-kmtmrgl.png)​

‍

### 堆栈的区别是什么？

1、栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。

2、栈内存是线程私有的，而堆内存是线程共有的。

3、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。

栈空间不足：java.lang.StackOverFlowError。

堆空间不足：java.lang.OutOfMemoryError。

‍

‍

## 类加载器

类加载器根据各自加载范围的不同，划分为四种类加载器：

* **启动类加载器(BootStrap ClassLoader)：**   
  该类并不继承ClassLoader类，其是由C++编写实现。用于加载**JAVA_HOME/jre/lib**目录下的类库。
* **扩展类加载器(ExtClassLoader)：**   
  该类是ClassLoader的子类，主要加载**JAVA_HOME/jre/lib/ext**目录中的类库。
* **应用类加载器(AppClassLoader)：**   
  该类是ClassLoader的子类，主要用于加载**classPath**下的类，也就是加载开发者自己编写的Java类。
* **自定义类加载器：**   
  开发者自定义类继承ClassLoader，实现自定义类加载规则。

类加载器的体系并不是“继承”体系，而是**委派体系**，类加载器首先会到自己的parent中查找类或者资源，如果找不到才会到自己本地查找。类加载器的委托行为动机是为了避免相同的类被加载多次。

‍

‍

### 采用双亲委派机制

（1）通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。

（2）为了安全，保证类库API不会被修改(重名报错)

‍

‍

### 说一下类装载的执行过程？

类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）。

‍

**类加载过程详解**

1.加载

* 通过类的全名，获取类的二进制数据流。
* 解析类的二进制数据流为方法区内的数据结构（Java类模型）
* 创建java.lang.Class类的实例，表示该类型。作为访问该类在方法区中的数据的入口

​![image](assets/image-20241116234429-fql8al6.png)​

‍

‍

2.验证

**验证类是否符合JVM规范，安全性检查**

(1)文件格式验证:是否符合Class文件的规范  
(2)元数据验证  
这个类是否有父类（除了Object这个类之外，其余的类都应该有父类）  
这个类是否继承（extends）了被final修饰过的类（被final修饰过的类表示类不能被继承）  
类中的字段、方法是否与父类产生矛盾。（被final修饰过的方法或字段是不能覆盖的）  
(3)字节码验证  
主要的目的是通过对数据流和控制流的分析，确定程序语义是合法的、符合逻辑的。  
(4)符号引用验证：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量

‍

3.准备

**为类变量分配内存并设置类变量初始值**

* static变量，分配空间在准备阶段完成（设置默认值），赋值在初始化阶段完成
* static变量是final的基本类型，以及字符串常量，值已确定，赋值在准备阶段完成
* static变量是final的引用类型，那么赋值也会在初始化阶段完成

‍

‍

4.解析

**把类中的符号引用转换为直接引用**

比如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。

‍

5.初始化

**对类的静态变量，静态代码块执行初始化操作**

* 如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。
* 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。

‍

6.使用

JVM 开始从入口方法开始执行用户的程序代码

* 调用静态类成员信息（比如：静态字段、静态方法）
* 使用new关键字为其创建对象实例

‍

7.卸载

当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存

‍

## 垃圾回收

> **面试官**： 你能详细聊一下分代回收吗？
>
> **候选人:**
>
> 关于分代回收是这样的
>
> 在java8时，堆被分为了两份：新生代和老年代，它们默认空间占用比例是1:2
>
> 对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区默认空间占用比例是8:1:1
>
> 具体的工作机制是有些情况：
>
> 1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。
>
> 2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且**当前对象的年龄会加1**，清空Eden区。
>
> 3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年龄会加1，清空Eden区和S0区。
>
> 4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年龄会加1，清空Eden区和S1区。
>
> 5）对象的年龄达到了某一个限定的值（**默认15岁** ），那么这个对象就会进入到老年代中。
>
> 当然也有特殊情况，如果进入Eden区的是一个大对象，在触发YoungGC的时候，会直接存放到老年代
>
> 当老年代满了之后，**触发FullGC**。**FullGC同时回收新生代和老年代**，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。 我们在程序中要尽量避免FullGC的出现。
>
> **面试官**：讲一下新生代、老年代、永久代的区别？
>
> **候选人:**
>
> 嗯！是这样的，简单说就是
>
> **新生代**主要用来存放新生的对象。
>
> **老年代**主要存放应用中生命周期长的内存对象。
>
> **永久代**指的是永久保存区域。主要存放Class和Meta（元数据）的信息。在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（**元空间**）的区域。元空间和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。
>
> **面试官**：说一下 JVM 有哪些垃圾回收器？
>
> **候选人:**
>
> 在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器（JDK8默认）、CMS（并发）垃圾收集器、G1垃圾收集器（JDK9默认）
>
> **面试官**：Minor GC、Major GC、Full GC是什么
>
> **候选人:**
>
> 嗯，其实它们指的是不同代之间的垃圾回收
>
> Minor GC 发生在新生代的垃圾回收，暂停时间短
>
> Major GC 老年代区域的垃圾回收，老年代空间不足时，会先尝试触发Minor GC。Minor GC之后空间还不足，则会触发Major GC，Major GC速度比较慢，暂停时间长
>
> Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，**应尽力避免**

‍

‍

### 简述Java垃圾回收机制？（GC是什么？为什么要GC）

为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。

有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。

在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机

换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致内存资源一直没有释放，同样也可能会导致内存溢出的。

当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。

‍

‍

### 对象什么时候可以被垃圾器回收

简单一句就是：如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。

如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法

‍

#### 引用计数法

‍

优点：

* 实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。
* 在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报OOM错误。
* 区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。

缺点：

* 每次对象被引用时，都需要去更新计数器，有一点时间开销。
* **浪费CPU资源**，即使内存够用，仍然在运行时进行计数器的统计。
* **无法解决循环引用问题，会引发内存泄露**。（最大的缺点）

‍

‍

#### 可达性分析算法

 现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾。

 会存在一个根节点【GC Roots】，引出它下面指向的下一个节点，再以下一个节点节点开始找出它下面的节点，依次往下类推。直到所有的节点全部遍历完毕。

> 根对象是那些肯定不能当做垃圾回收的对象，就可以当做根对象
>
> 局部变量，静态方法，静态变量，类信息
>
> 核心是：判断某对象是否与根对象有直接或间接的引用，如果没有被引用，则可以当做垃圾回收

 X,Y这两个节点是可回收的，但是**并不会马上的被回收！！**  对象中存在一个方法【finalize】。当对象被标记为可回收后，当发生GC时，首先**会判断这个对象是否执行了finalize方法**，如果这个方法还没有被执行的话，那么就会先来执行这个方法，接着在这个方法执行中，可以设置当前这个对象与GC ROOTS产生关联，那么这个方法执行完成之后，GC会再次判断对象是否可达，如果仍然不可达，则会进行回收，如果可达了，则不会进行回收。

 finalize方法对于每一个对象来说，只会执行一次。如果第一次执行这个方法的时候，设置了当前对象与RC ROOTS关联，那么这一次不会进行回收。 那么等到这个对象第二次被标记为可回收时，那么该对象的finalize方法就不会再次执行了。

‍

**GC ROOTS：**

* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象

‍

‍

### 分代收集算法

#### 概述

在java8时，堆被分为了两份：**新生代和老年代【1：2】** ，在java7时，还存在一个永久代

对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区【8：1：1】

当对新生代产生GC：MinorGC【young GC】

当对老年代代产生GC：Major GC

当对新生代和老年代产生FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长，**应尽力避免**

‍

**MinorGC、 Mixed GC 、 FullGC的区别是什么**

* MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短（STW）
* Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有
* FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长（STW），应尽力避免？

‍

‍

### JVM 有哪些垃圾回收器

在jvm中，实现了多种垃圾收集器，包括：

* 串行垃圾收集器
* 并行垃圾收集器
* CMS（并发）垃圾收集器
* G1垃圾收集器

‍

#### 串行垃圾收集器

Serial和Serial Old串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑

* Serial 作用于新生代，采用复制算法
* Serial Old 作用于老年代，采用标记-整理算法

垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。

‍

#### 并行垃圾收集器

Parallel New和Parallel Old是一个并行垃圾回收器，**JDK8默认使用此垃圾回收器**

* Parallel New作用于新生代，采用复制算法
* Parallel Old作用于老年代，采用标记-整理算法

垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。

‍

#### CMS（并发）垃圾收集器

CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。

‍

‍

### G1垃圾回收器

‍

#### 概述

* 应用于新生代和老年代，**在JDK9之后默认使用****G1**
* 划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备
* 采用复制算法
* 响应时间与吞吐量兼顾
* 分成三个阶段：新生代回收、并发标记、混合收集
* 如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC

‍

### 强引用、软引用、弱引用、虚引用的区别？

‍

#### 强引用

强引用：只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收

```java
User user = new User();
```

‍

#### 软引用

软引用：仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收

```java
User user = new User();
SoftReference softReference = new SoftReference(user);
```

‍

#### 弱引用

弱引用：仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象

```java
User user = new User();
WeakReference weakReference = new WeakReference(user);
```

‍

#### 虚引用

虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存

‍

> 强引用最为普通的引用方式，表示一个对象处于**有用且必须**的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收
>
> 软引用表示一个对象处于**有用且非必须**状态，如果一个对象处于软引用，在内存空间足够的情况下，GC机制并不会回收它，而在内存空间不足时，则会在OOM异常出现之间对其进行回收。但值得注意的是，因为GC线程优先级较低，软引用并不会立即被回收。
>
> 弱引用表示一个对象处于**可能有用且非必须**的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收。同样的，因为GC线程优先级较低，所以弱引用也并不是会被立刻回收。
>
> 虚引用表示一个对象处于**无用**的状态。在任何时候都有可能被垃圾回收。虚引用的使用必须和引用队列Reference Queue联合使用

‍

‍

## JVM实践（调优）

阿尔萨斯一站式解决问题, 帅

‍

> **面试官**：JVM 调优的参数可以在哪里设置参数值？
>
> **候选人:**
>
> 我们当时的项目是springboot项目，可以在项目启动的时候，java -jar中加入参数就行了
>
> **面试官**：用的 JVM 调优的参数都有哪些？
>
> **候选人:**
>
> 嗯，这些参数是比较多的
>
> 我记得当时我们设置过堆的大小，像-Xms和-Xmx
>
> 还有就是可以设置年轻代中Eden区和两个Survivor区的大小比例
>
> 还有就是可以设置使用哪种垃圾回收器等等。具体的指令还真记不太清楚。
>
> **面试官**：嗯，好的，你们平时调试 JVM都用了哪些工具呢？
>
> **候选人:**
>
> 嗯，我们一般都是使用jdk自带的一些工具，比如
>
> jps 输出JVM中运行的进程状态信息
>
> jstack查看java进程内**线程的堆栈**信息。
>
> jmap 用于生成堆转存快照
>
> jstat用于JVM统计监测工具
>
> 还有一些可视化工具，像jconsole和VisualVM等
>
> **面试官**：假如项目中产生了java内存泄露，你说一下你的排查思路？
>
> **候选人:**
>
> 嗯，这个我在之前项目排查过
>
> 第一呢可以通过jmap指定打印他的内存快照 dump文件，不过有的情况打印不了，我们会设置vm参数让程序自动生成dump文件
>
> 第二，可以通过工具去分析 dump文件，jdk自带的VisualVM就可以分析
>
> 第三，通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题
>
> 第四，找到对应的代码，通过阅读上下文的情况，进行修复即可
>
> **面试官**：好的，那现在再来说一种情况，就是说服务器CPU持续飙高，你的排查方案与思路？
>
> **候选人:**
>
> 嗯，我思考一下~~
>
> 可以这么做~~
>
> 第一可以使用使用top命令查看占用cpu的情况
>
> 第二通过top命令查看后，可以查看是哪一个进程占用cpu较高，记录这个进程id
>
> 第三可以通过ps 查看当前进程中的线程信息，看看哪个线程的cpu占用较高
>
> 第四可以jstack命令打印进行的id，找到这个线程，就可以进一步定位问题代码的行号

‍

还有个

> 结合Linux 和 JDK命令一起分析，步骤如下
>
> * 使用top命令找出CPU占比最高的
> * ps -ef 或者 jps 进一步定位，得知是一个怎么样的后台程序出的问题
> * 定位到具体线程或者代码
>
>   * ps -mp 进程 -o THREAD，tid，time
>   * 参数解释
>
>     * -m：显示所有的线程
>     * -p：pid进程使用CPU的时间
>     * -o：该参数后是用户自定义格式
>   * 将需要的线程ID转换为16进制格式（英文小写格式）
>
>     * printf “%x\n” 有问题的线程ID
>   * jstack 进程ID | grep tid（16进制线程ID小写英文） -A60  
>     精准定位到错误的地方

‍

‍

### JVM 调优的参数可以在哪里设置参数值

‍

#### tomcat的设置vm参数

修改TOMCAT_HOME/bin/catalina.sh文件

‍

#### springboot项目jar文件启动

通常在linux系统下直接加参数启动springboot项目

```bash
nohup java -Xms512m -Xmx1024m -jar xxxx.jar --spring.profiles.active=prod &
```

> nohup : 用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行
>
> 参数  **&amp;**  ：让命令在后台执行，终端退出后命令仍旧执行。

‍

‍

‍

### 用的 JVM 调优的参数都有哪些？

 对于JVM调优，主要就是调整年轻代、年老大、元空间的内存空间大小及使用的垃圾回收器类型。

[https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html](https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html)

1）设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。

```text
-Xms：设置堆的初始化大小

-Xmx：设置堆的最大大小
```

2） 设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。Java官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满

的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。

```text
-XXSurvivorRatio=3，表示年轻代中的分配比率：survivor:eden = 2:3
```

3）年轻代和老年代默认比例为1：2。可以通过调整二者空间大小比率来设置两者的大小。

```text
-XX:newSize   设置年轻代的初始大小
-XX:MaxNewSize   设置年轻代的最大大小，  初始大小和最大大小两个值通常相同
```

4）线程堆栈的设置：**每个线程默认会开启1M的堆栈**，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。

```text
-Xss   对每个线程stack大小的调整,-Xss128k
```

5）一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用-Xmn设置年轻代的大小

6）系统CPU持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决。

7）对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：-XX:PetenureSizeThreshold=1000000，单位为B，标明对象大小超过1M时，在老年代(tenured)分配内存空间。

8）一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值，就被放到tenured老年区。这个阈值可以同构-XX:MaxTenuringThreshold设置。如果想让对象留在年轻代，可以设置比较大的阈值。

```text
（1）-XX:+UseParallelGC:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。

（2）-XX:+UseParallelOldGC:设置老年代使用并行垃圾回收收集器。
```

9）尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统的性能。

```text
-XX:+LargePageSizeInBytes 设置内存页的大小
```

10）使用非占用的垃圾收集器。

```text
-XX:+UseConcMarkSweepGC老年代使用CMS收集器降低停顿。
```

‍

‍

### JVM 调优的工具

‍

#### 命令工具

‍

##### jps（Java Process Status）

输出JVM中运行的进程状态信息(现在一般使用jconsole)

‍

##### jstack

查看java进程内**线程的堆栈**信息。

```bash
jstack [option] <pid>  
```

‍

##### jmap

用于生成堆转存快照

> jmap [options] pid 内存映像信息
>
> jmap -heap pid 显示Java堆的信息
>
> jmap -dump:format=b,file=heap.hprof pid
>
> format=b表示以hprof二进制格式转储Java堆的内存  
> file=用于指定快照dump文件的文件名。

‍

##### jhat

用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer）

‍

##### jstat

是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。

**常见参数**：

①总结垃圾回收统计

```bash
jstat -gcutil pid
```

‍

|字段|含义|
| ------| ------------------------|
|S0|幸存1区当前使用比例|
|S1|幸存2区当前使用比例|
|E|伊甸园区使用比例|
|O|老年代使用比例|
|M|元数据区使用比例|
|CCS|压缩使用比例|
|YGC|年轻代垃圾回收次数|
|YGCT|年轻代垃圾回收消耗时间|
|FGC|老年代垃圾回收次数|
|FGCT|老年代垃圾回收消耗时间|
|GCT|垃圾回收消耗总时间|

‍

②垃圾回收统计

```bash
jstat -gc pid
```

‍

‍

#### 可视化工具

‍

##### jconsole

用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具

打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行

‍

可以内存、线程、类等信息

‍

##### VisualVM：故障处理工具

能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈

打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行

监控程序运行情况, 查看运行中的dump, 查看堆中的信息都行

‍

‍

### java内存泄露的排查思路？

如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量的时候，java虚拟机将抛出一个StackOverFlowError异常

如果java虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个OutOfMemoryError异常

如果一次加载的类太多，元空间内存不足，则会报OutOfMemoryError: Metaspace

‍

1、通过jmap指定打印他的内存快照 dump

> 有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式的生成dump文件，配置如下：
>
> -XX:+HeapDumpOnOutOfMemoryError  
> -XX:HeapDumpPath=/home/app/dumps/ 指定生成后文件的保存目录

‍

2、通过工具， VisualVM（Ecplise MAT）去分析 dump文件

VisualVM可以加载离线的dump文件，如下图

文件-->装入--->选择dump文件即可查看堆快照信息

> 如果是linux系统中的程序，则需要把dump文件下载到本地（windows环境）下，打开VisualVM工具分析。VisualVM目前只支持在windows环境下运行可视化

‍

3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题

‍

4、找到对应的代码，通过阅读上下文的情况，进行修复即可

‍

### CPU飙高排查方案与思路

1.使用top命令查看占用cpu的情况

2.通过top命令查看后，可以查看是哪一个进程占用cpu较高，上图所示的进程为：30978

3.查看当前线程中的进程信息

```bash
ps H -eo pid,tid,%cpu | grep 30978
```

> pid 进行id
>
> tid 进程中的线程id
>
> % cpu使用率

4.通过上图分析，在进程30978中的线程30979占用cpu较高

> 注意：上述的线程id是一个十进制，我们需要把这个线程id转换为16进制才行，因为通常在日志中展示的都是16进制的线程id名称
>
> 转换方式：
>
> 在linux中执行命令
>
> ​`printf "%x\n" 30979`​

5.可以根据线程 id 找到有问题的线程，进一步定位到问题代码的源码行号

执行命令

```bash
jstack 30978   此处是进程id
```

‍
