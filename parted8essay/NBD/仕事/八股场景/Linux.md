‍

‍

# 概念

‍

## 零碎

‍

### linux的常用命令

find 、rm、rmdir、mv、cp、cat、pwd、chmod、kill、ping、ifconfig

tail、ps、grep、netstat、echo、ssh、scp、top、mpstat、free、df

‍

* man, 查看文档
* lsof -i :{port}  查看占用某个端口的进程
* find ./ -name filename    搜索当前目录下某个名字的文件
* wc [选项] 文件1 文件2  
    -c 统计字节数  
    -l 统计行数  
    -w 统计字数

  统计文件行数
* ‍

‍

‍

‍

‍

‍

### 从linux命令和日志层面分析问题

发现业务问题后，首先到linux里用vi命令打开日志，然后用关键字去搜索，根据时间定位到日志后，再根据traceid或线程号找到错误日志的上下文

> 找到业务问题后，别展开讲，因为面试官不关心业务，而可以直接说，解决了空指针等问题.

‍

‍

### Linux cpu或内存OOM问题

一般说辞是，用linux命令排序看下当下哪个线程CPU或内存用量过高，必要时再看下dump文件，用jstack或jmap命令分析一下

这块更可以参考别人的问题排查经验，比如下文给出了一次排查内存问题的经验，其中是因为用到的对象没关掉. 那你也可以结合业务说，比如你是做支付的，支付后连接网银的对象没关，所以导致了OOM.

‍

### 在linux里面有两个进程，一个进行在修改这个文件，另外一个去删除这个文件，会发生什么？

在 Linux 中，如果一个进程正在修改一个文件，而另一个进程删除了这个文件，会发生以下情况：

1. **文件描述符**：正在修改文件的进程持有该文件的文件描述符。即使文件被删除，文件描述符仍然有效，进程可以继续修改文件。
2. **文件删除**：文件被删除后，文件名从文件系统中移除，但文件数据仍然存在，直到所有引用该文件的文件描述符关闭为止。
3. **数据一致性**：正在修改文件的进程可以继续对文件进行读写操作，直到它关闭文件描述符。此时，文件数据才会真正从磁盘上删除。

总结：文件被删除后，正在修改文件的进程不会立即受到影响，可以继续操作文件，直到关闭文件描述符。文件数据在所有文件描述符关闭后才会被真正删除。

‍

### 如果多用户场景下cpu存在瓶颈，执行不过来，如何定位在哪一个环节？

1. **使用** **​`top`​**​ **或** **​`htop`​**​ **命令**：查看系统中 CPU 使用率较高的进程。
2. **使用** **​`pidstat`​**​ **命令**：查看各个进程的 CPU 使用情况。
3. **使用** **​`perf`​**​ **工具**：分析具体的函数调用和 CPU 使用情况。
4. **使用** **​`strace`​**​ **工具**：跟踪系统调用，查看是否有大量的系统调用导致 CPU 瓶颈。
5. **分析应用日志**：查看应用日志，定位是否有特定的操作或请求导致 CPU 使用率飙升。
6. **使用 Java Profiling 工具**：如 VisualVM、YourKit 或 JProfiler，分析 Java 应用的 CPU 使用情况。

以下是一些常用命令的示例：

```sh
# 查看系统中 CPU 使用率较高的进程
top

# 查看各个进程的 CPU 使用情况
pidstat -u 1

# 使用 perf 工具分析具体的函数调用和 CPU 使用情况
perf top

# 跟踪系统调用
strace -p <pid>

# 使用 VisualVM 分析 Java 应用的 CPU 使用情况
jvisualvm
```

通过这些工具和方法，可以逐步定位到具体的瓶颈环节，从而进行优化。

‍

‍

## 硬链接和软链接的区别?

在 Linux 中，硬链接和软链接（符号链接）是两种不同的文件链接方式，它们有以下区别：

* **硬链接**：共享相同的 inode 号，不能跨文件系统，不能对目录创建。
* **软链接**：有自己的 inode 号，存储路径信息，可以跨文件系统，可以对目录创建。

‍

### 硬链接 (Hard Link)

* **定义**：硬链接是指向同一文件数据块的多个文件名。
* **特点**：

  * 硬链接共享相同的 inode 号。
  * 删除一个硬链接不会影响其他硬链接，只有当所有硬链接都被删除时，文件数据才会被删除。
  * 不能跨文件系统创建硬链接。
  * 不能对目录创建硬链接。
* **创建**：使用 `ln`​ 命令。

  ```sh
  ln source_file hard_link
  ```

‍

‍

### 软链接 (Symbolic Link)

* **定义**：软链接是一个指向另一个文件或目录的路径名。
* **特点**：

  * 软链接有自己的 inode 号和数据块，数据块中存储的是目标文件的路径。
  * 删除软链接不会影响目标文件，但如果目标文件被删除，软链接会变成**无效链接**（悬挂链接）。
  * 可以跨文件系统创建软链接。
  * 可以对目录创建软链接。
* **创建**：使用 `ln -s`​ 命令。

  ```sh
  ln -s target_file symbolic_link
  ```

‍

‍

## inode是什么

inode（索引节点）是一个数据结构，用于存储文件的**元数据**。

每个文件和目录都有一个唯一的 inode，包含以下信息：

* 文件类型（如普通文件、目录、符号链接等）
* 文件权限（读、写、执行权限）
* 文件所有者和所属组
* 文件大小
* 文件的时间戳（创建时间、修改时间、访问时间）
* 链接计数（指向该文件的硬链接数量）
* 数据块指针（指向文件数据所在的磁盘块）

‍

inode 不包含文件名。文件名和 inode 之间的映射关系存储在目录项中。

可以使用 `ls -i`​ 命令查看文件的 inode 号：

```sh
ls -i filename
```

例如：

```sh
$ ls -i /etc/passwd
123456 /etc/passwd
```

这将显示 `/etc/passwd`​ 文件的 inode 号为 123456。

‍

‍

‍

### 在Linux下怎么查看Java线程吗？

在 Linux 下查看 Java 线程可以使用 `jstack`​ 工具。`jstack`​ 是 JDK 提供的一个工具，用于生成 Java 虚拟机中线程的堆栈跟踪。以下是使用 `jstack`​ 查看 Java 线程的步骤：

1. **找到 Java 进程的 PID**：  
    使用 `jps`​ 或 `ps`​ 命令找到正在运行的 Java 进程的 PID（进程 ID）。

    ```sh
    jps -l
    ```

    或者

    ```sh
    ps -ef | grep java
    ```
2. **使用** **​`jstack`​**​ **查看线程堆栈**：  
    使用 `jstack`​ 命令并传入找到的 PID 来查看线程堆栈。

    ```sh
    jstack <pid>
    ```

    例如，如果 Java 进程的 PID 是 12345，则命令如下：

    ```sh
    jstack 12345
    ```
3. **分析输出**：  
    ​`jstack`​ 的输出将显示所有线程的堆栈跟踪信息，可以用来分析线程的状态和活动。

‍

示例：

```sh
$ jps -l
12345 com.example.MyApplication

$ jstack 12345
```

这将输出 Java 进程 12345 的所有线程堆栈信息。

‍

# 大块

‍

‍

# 高级

‍

## Linux诊断操作集合

‍

‍

### top，查看整机系统性能

使用top命令的话，重点关注的是 %CPU、%MEM 、load average 三个指标

* load average三个指标：分别代表1、5、15分钟的负载情况. 这些值如果超过0.6的话就很高了(百分比)

在这个命令下，按1的话，可以看到每个CPU的占用情况

uptime：系统性能命令的精简版, 只看到用户等信息

```java
 14:20:15 up 20 days,  2:16,  1 user,  load average: 0.07, 0.06, 0.08
```

‍

### CPU：vmstat

* 查看CPU（包含但是不限于）    vmstat
* 查看额外

  * 查看所有CPU核信息：    mpstat -p ALL 2
  * 每个进程使用CPU的用量分解信息：pidstat -u 1 -p 进程编号

命令格式：`vmstat -n 2 3`​

一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数（单位秒），第二个参数是采样的次数

‍

**procs**

 r：运行和等待的CPU时间片的进程数，原则上1核的CPU的运行队列不要超过2，整个系统的运行队列不超过总核数的2倍，否则代表系统压力过大，我们看蘑菇博客测试服务器，能发现都超过了2，说明现在压力过大

 b：等待资源的进程数，比如正在等待磁盘I/O、网络I/O等

‍

**cpu**

 us：用户进程消耗CPU时间百分比，us值高，用户进程消耗CPU时间多，如果长期大于50%，优化程序

 sy：内核进程消耗的CPU时间百分比

 us + sy 参考值为80%，如果us + sy 大于80%，说明可能存在CPU不足，从上面的图片可以看出，us + sy还没有超过百分80，因此说明蘑菇博客的CPU消耗不是很高

 id：处于空闲的CPU百分比

 wa：系统等待IO的CPU时间百分比

 st：来自于一个虚拟机偷取的CPU时间比

‍

### 内存：free

* 应用程序可用内存数：free -m
* 应用程序可用内存/系统物理内存 > 70% 内存充足
* 应用程序可用内存/系统物理内存 < 20% 内存不足，需要增加内存
* 20% < 应用程序可用内存/系统物理内存 < 70%，表示内存基本够用

free -h：以人类能看懂的方式查看物理内存

free -m：以MB为单位，查看物理内存

free -g：以GB为单位，查看物理内存

‍

### 硬盘：df

格式：`df -h /`​ (-h：human，表示以人类能看到的方式换算)

* 硬盘IO：iostat

系统慢有两种原因引起的，一个是CPU高，一个是大量IO操作

格式：`iostat -xdk 2 3`​

‍

磁盘块设备分布：

rkB /s：每秒读取数据量kB；

wkB/s：每秒写入数据量kB；

svctm I/O：请求的平均服务时间，单位毫秒

await I/O：请求的平均等待时间，单位毫秒，值越小，性能越好

util：一秒钟有百分几的时间用于I/O操作。接近100%时，表示磁盘带宽跑满，需要优化程序或者增加磁盘；

rkB/s，wkB/s根据系统应用不同会有不同的值，但有规律遵循：长期、超大数据读写，肯定不正常，需要优化程序读取。

svctm的值与await的值很接近，表示几乎没有I/O等待，磁盘性能好，如果await的值远高于svctm的值，则表示I/O队列等待太长，需要优化程序或更换更快磁盘

‍

### 网络IO：ifstat

* 默认本地没有，下载ifstat
