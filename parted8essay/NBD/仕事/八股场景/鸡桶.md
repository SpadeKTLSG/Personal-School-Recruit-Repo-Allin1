‍

机组操原专供

Link

[🗂【面试题】技术面试题汇总 🔥 (imageslr.com)   ](https://imageslr.com/2020/07/08/tech-interview.html)

‍

‍

# 概念

‍

## 零碎

‍

### 查看某个进程中的线程

ps -T -p <pid>

‍

‍

## 编码问题

‍

### **ASCII 码**

计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有`0`​和`1`​两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从`00000000`​到`11111111`​。

上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。

ASCII 码一共规定了128个字符的编码，比如空格`SPACE`​是32（二进制`00100000`​），大写的字母`A`​是65（二进制`01000001`​）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为`0`​。

‍

### **非 ASCII 编码**

英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。

亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。

GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。

‍

### **Unicode**

如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码

Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。

‍

‍

### **UTF-8**

互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。**重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。**

UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。

UTF-8 的编码规则很简单，只有二条：

1）对于单字节的符号，字节的第一位设为`0`​，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。

2）对于`n`​字节的符号（`n > 1`​），第一个字节的前`n`​位都设为`1`​，第`n + 1`​位设为`0`​，后面字节的前两位一律设为`10`​。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

‍

‍

## 单核 CPU 上运行死循环程序咋样

在单核 CPU 上运行死循环程序时，操作系统调度器通过以下步骤来管理 CPU 资源：

‍

1. **时间片轮转**：操作系统使用**时间片轮转调度**算法，将 CPU 时间分成若干个**时间片**（通常是几毫秒）。每个进程在其时间片内运行，时间片结束后，调度器会将 CPU 切换到下一个进程。
2. **中断**：当一个进程的时间片用完时，硬件定时器会触发一个**时钟中断**。中断处理程序会暂停当前进程的执行，并将控制权交给操作系统内核。
3. **上下文切换**：操作系统内核保存当前进程的状态（如寄存器、程序计数器等），然后加载下一个进程的状态。这一过程称为上下文切换。
4. **调度**：调度器根据调度算法（如优先级调度、时间片轮转等）选择下一个要运行的进程，并将其分配给 CPU。

即使一个进程进入死循环，操作系统调度器仍然能够通过**时间片轮转**和**中断机制**确保其他进程有机会获得 CPU 资源

‍

```plaintext
进程 A (死循环)  -->  时间片结束  -->  时钟中断  -->  上下文切换  -->  进程 B 运行  -->  时间片结束  -->  时钟中断  -->  上下文切换  -->  进程 A 继续运行
```

这个过程确保了即使在单核 CPU 上，操作系统也能公平地分配 CPU 资源给所有进程。

‍

‍

## 用户态 内核态切换场景

1. **系统调用**
2. **硬件中断**
3. **异常处理**
4. **上下文切换**：当操作系统进行进程调度时，需要保存当前进程的状态并加载下一个进程的状态。这一过程也涉及用户态和内核态的切换。

这些切换场景确保了用户程序和操作系统内核之间的隔离，防止用户程序直接访问和修改系统资源，从而提高系统的安全性和稳定性。

‍

‍

## 局部性原理在计算机领域的应用

‍

1. **时间局部性**：时间局部性指的是如果某个数据被访问过，那么在不久的将来它很可能会再次被访问。虚拟内存管理通过将最近访问的数据保存在高速缓存中来利用时间局部性，从而减少访问内存的时间。
2. **空间局部性**：空间局部性指的是如果某个数据被访问过，那么它附近的数据很可能也会被访问。虚拟内存管理通过将相邻的数据块一起加载到内存中来利用空间局部性，从而提高内存访问效率。

‍

在虚拟内存管理中，局部性原理的应用主要体现在以下几个方面：

* **页面置换算法**：操作系统使用页面置换算法（如LRU算法）来决定哪些页面应该被保留在内存中，哪些页面应该被换出。LRU算法利用时间局部性，优先保留最近使用的页面。
* **预取机制**：操作系统可以通过预取机制利用空间局部性，将相邻的页面提前加载到内存中，从而减少缺页中断的次数。
* **缓存管理**：操作系统和硬件通过多级缓存（如L1、L2、L3缓存）来利用时间局部性和空间局部性，提高内存访问速度。

这些机制共同作用，提高了系统的性能和效率。

‍

## 虚拟内存管理

虚拟内存管理是操作系统用来管理计算机内存的一种机制。它通过将物理内存抽象为虚拟地址空间，使得每个程序都认为自己在使用连续的内存空间，而实际上这些地址可能被映射到不同的物理内存位置。

1. **程序打印出来的指针属于什么**：

    * 程序打印出来的指针是虚拟地址。它是程序在其虚拟地址空间中使用的地址。
2. **属于虚拟内存吗**：

    * 是的，程序打印出来的指针属于虚拟内存。操作系统将这些虚拟地址映射到物理内存地址。
3. **两个程序能否打印相同的地址吗**：

    * 是的，两个程序可以打印相同的虚拟地址。每个程序都有自己的独立虚拟地址空间，因此相同的虚拟地址在不同的程序中可以指向不同的物理内存位置。
4. **不同的虚拟地址能否映射到同一块物理空间呢**：

    * 是的，不同的虚拟地址可以映射到同一块物理内存。这种情况在共享内存或内存映射文件等机制中很常见。操作系统通过页表来管理这些映射关系。

‍

‍

# 大块

‍

## 用户态内核态

‍

### 为何要区分用户态和内核态

最简单的运行程序的方式是“直接执行”，即直接在 CPU 上执行任意程序。直接执行的问题是：

1. 如何限制代码行为？比如禁止：设置特殊寄存器的值、访问存储器的任意位置、I/O 请求、申请更多系统资源等
2. 在运行这个程序的时候，如何切换到另一个程序？进程调度应该是 OS 才有的权限

因此引入用户态和内核态和两种模式。用户态无法执行受限操作，如 I/O 请求，执行这些操作会引发异常。核心态只能由操作系统运行，可以执行特权操作。用户程序通过**系统调用** system call 执行这些特权操作。OS 执行前会判断进程是否有**权限**执行相应的指令。

区分用户态和核心态的执行机制称为“受限直接执行”（Limited Direct Execution）。

‍

‍

### 什么时候会陷入内核态

**系统调用（trap）、中断（interrupt）和异常（exception）**

系统调用是用户进程主动发起的操作。发起系统调用，陷入内核，由操作系统执行系统调用，然后再返回到进程。

中断和异常是被动的，无法预测发生时机。中断包括 I/O 中断、外部信号中断、各种定时器引起的时钟中断等。异常包括程序运算引起的各种错误如除 0、缓冲区溢出、缺页等。

在系统的处理上，中断和异常类似，都是通过中断向量表来找到相应的处理程序进行处理。区别在于，中断来自处理器外部，不是由任何一条专门的指令造成，而异常是执行当前指令的结果。

‍

‍

## 进程间的通信方式

* 信号
* 管道
* 信号量
* 共享内存
* 消息队列
* 套接字

|方式|传输的信息量|使用场景|关键词|
| ----------| --------------------| ----------------| ------------------------------------------------------------------------|
|信号|少量|任何|硬件来源、软件来源 / 信号队列|
|管道|大量|亲缘进程间|单向流动 / 内核缓冲区 / 循环队列 / 没有格式的字节流 / 操作系统负责同步|
|命名管道|大量|任何|磁盘文件 / 访问权限 / 无数据块 / 内核缓冲区 / 操作系统负责同步|
|信号量|N|任何|互斥同步 / 原子性 / P 减 V 增|
|共享内存|大量|多个进程|内存映射 / 简单快速 / 操作系统不保证同步|
|消息队列|比信号多，但有限制|任何|有格式 / 按消息类型过滤 / 操作系统负责同步|
|套接字|大量|不同主机的进程|读缓存区 / 写缓冲区 / 操作系统负责同步|

‍

‍

‍

# 高级

‍

## I/O 多路复用

[【操作系统】I/O 多路复用，select / poll / epoll 详解 (imageslr.com)](https://imageslr.com/2020/02/27/select-poll-epoll)

‍

阻塞 I/O，是指进程发起调用后，会被挂起（阻塞），直到收到数据再返回。如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞 I/O 时，需要使用**多线程**来处理多个文件描述符。

多线程切换有一定的开销，因此引入非阻塞 I/O。非阻塞 I/O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在**一个线程**里*轮询*多个文件描述符是否就绪。

但是非阻塞 I/O 的缺点是：每次发起系统调用，只能检查**一个**文件描述符是否就绪。当文件描述符很多时，系统调用的成本很高。

因此引入了 I/O 多路复用，可以**通过一次系统调用，检查多个文件描述符的状态**。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。

‍

I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了**内核**中，由内核来负责轮询。

进程可以通过 select、poll、epoll 发起 I/O 多路复用的系统调用，这些系统调用都是同步阻塞的：**如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后，再返回**。I/O 多路复用内部使用*非阻塞 I/O* 检查每个描述符的就绪状态。

如果 `timeout`​ 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 `timeout`​ 参数设为 0，会立即返回，不阻塞。

I/O 多路复用引入了一些额外的操作和开销，性能更差。但是好处是用户可以在一个线程内同时处理多个 I/O 请求。如果不采用 I/O 多路复用，则必须通过多线程的方式，每个线程处理一个 I/O 请求。后者线程切换也是有一定的开销的

‍

‍

‍

‍

### Redis的应用

Redis 是一个单线程的工作模型，使用 I/O 多路复用来处理客户端的多个连接。为什么 Redis 选择单线程也能效率这么高？

I/O 设备（如磁盘、网络）等速度远远慢于 CPU，因此引入了多线程技术。当一个线程发起 I/O 请求时，先将它挂起，切换到别的线程；当 I/O 设备就绪时，再切换回该线程。总之，**多线程技术是为了充分利用 CPU 的计算资源，适用于下层存储慢速的场景**。

而 redis 是纯内存操作，读写速度非常快。所有的操作都会在内存中完成，不涉及任何 I/O 操作，因此**多线程频繁的上下文切换反而是一种负优化**。Redis 选择基于非阻塞 I/O 的 **I/O 多路复用机制**，在单线程里**并发**处理客户端的多个连接，减少多线程带来的系统开销，同时也有更好的可维护性，方便开发和调试。

‍

不过 redis 在最新的几个版本中**也引入了多线程**，目的是：

1. **异步处理删除操作**。当删除超大键值对的时候，单线程内同步地删除可能会**阻塞**待处理的任务
2. 应对**网络 I/O** 的场景，网络 I/O 是慢速 I/O。redis6 吞吐量提高了 1 倍

‍

‍

## Copy-on-write

写时复制（Copy-on-write，COW），有时也称为隐式共享（implicit sharing）。COW **将复制操作推迟到第一次写入时**进行：在创建一个新副本时，不会立即复制资源，而是共享原始副本的资源；当修改时再执行复制操作。通过这种方式共享资源，可以显著减少创建副本时的开销，以及节省资源；同时，资源修改操作会增加少量开销。

‍

‍

## CPU跑满咋办了

当机器上的 CPU 跑满时，可以通过以下步骤进行排查：

‍

1. **使用操作系统工具**：

    * **Windows**：使用任务管理器（Task Manager）查看哪个进程占用了大量的 CPU 资源
    * **Linux**：使用 `top`​ 或 `htop`​ 命令查看 CPU 使用情况
2. **分析 Java 应用**：

    * **JVisualVM**：使用 JVisualVM 工具分析 Java 应用的 CPU 使用情况
    * **JStack**：使用 `jstack`​ 命令生成线程转储（thread dump），分析哪个线程占用了大量的 CPU 资源
3. **检查代码**：

    * **死循环**：检查代码中是否存在**死循环**或**高频率**的循环
    * **同步问题**：检查是否存在**线程同步**问题，导致线程竞争 CPU 资源
4. **性能分析工具**：

    * **Profiler**：使用**性能分析工具**（如 YourKit、JProfiler）进行详细的性能分析，找出性能瓶颈。

---

‍

### Linux `top`​ 命令

```sh
top
```

按 `P`​ 键按 CPU 使用率排序

‍

### JVisualVM

1. 启动 JVisualVM（通常在 JDK 的 `bin`​ 目录下）
2. 连接到正在运行的 Java 应用，查看 CPU 使用情况。

‍

### JStack

```sh
jstack <pid> > thread_dump.txt
```

分析生成的 `thread_dump.txt`​ 文件，找出占用 CPU 的线程

‍

‍

‍
