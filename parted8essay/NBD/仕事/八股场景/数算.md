‍

‍

# 概念

‍

## 零碎

‍

‍

### 外部排序的实现原理

外部排序是一种用于处理无法全部装入内存的大规模数据集的排序算法。其基本原理是将数据分成多个可以装入内存的小块，分别进行排序，然后将这些已排序的小块合并成一个有序的数据集。以下是外部排序的主要步骤：

1. **划分阶段**：将大数据集分成多个可以装入内存的小块。
2. **排序阶段**：将每个小块加载到内存中进行排序，然后将排序后的小块写回磁盘。
3. **合并阶段**：将多个已排序的小块合并成一个有序的数据集。

‍

‍

‍

## 红黑树

红黑树（Red Black Tree）是一种**自平衡二叉查找树**，它最早被称之为 “对称二叉 B 树”

‍

二叉查找树（Binary Search Tree）也被称为二叉搜索树、有序二叉树（Ordered Binary Tree）或排序二叉树（Sorted Binary Tree）等

一棵空树或者满足以下性质的二叉树被称之为二叉查找树： (左小右大)

* 若任意节点的左子树不为空，则左子树上所有节点的值均小于它的根节点的值；
* 若任意节点的右子树不为空，则右子树上所有节点的值均大于或等于它的根节点的值；
* 任意节点的左、右子树分别为二叉查找树。

‍

‍

**平衡树**是指一种改进的二叉查找树，顾名思义平衡树就是将二叉查找树平衡均匀地分布，这样的好处就是可以减少二叉查找树的深度。

当二叉查找树退化为链表数据结构后，再进行元素的添加、删除以及查询时，它的时间复杂度就会退化为 O(n)；而如果使用红黑树的话，它就会将以上数据转化为平衡二叉查找树，这样就可以更加高效的添加、删除以及查询数据了，这就是红黑树的优势。

红黑树保证平衡的手段有三个：变色、左旋和右旋。

‍

和 AVL 树不同的是，红黑树并不追求严格的平衡，而是**大致的平衡**。

正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行**多次磁盘 IO 操作才能查询到**，这也是 MySQL 没有选择红黑树的主要原因。--虽然红黑树的插入和删除操作效率大大提高了，因为红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O(logn) 次数的旋转操作

TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在**内存**中的这种情况来说，红黑树的表现是非常优异的。

‍

## 外部排序的实现原理

‍

‍

# 大块

‍

‍

‍

# 高级

‍

## 不同排序算法的适用场景

‍

1. 若 n 较小(如 n≤50)，可采用直接插入或直接选择排序。
2. 若文件初始状态基本有序，则应选用直接插人、冒泡或**随机的**快速排序。
3. 若 n 较大，则应采用时间复杂度为 O(nlogn) 的排序方法：快速排序、堆排序或归并排序。

    1. 当待排序的关键字是随机分布时，快速排序的平均时间最短。
    2. 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。
    3. 若要求排序稳定，则可选用归并排序。
    4. 归并排序需要较大的额外空间，但归并排序可以**多路归并**。
    5. 相比于从长度为 1 的序列开始归并，归并排序也可以和直接插入排序结合使用，先通过直接插入排序获得较长的有序序列，然后再进行归并。这种方式依然是稳定的。

大部分情况可以直接使用快速排序。

当待排序的关键字无法全部加载到内存中时，需要使用归并排序进行外部排序。

‍

‍

## 讲讲大根堆、小根堆是怎么维护的

‍

### 大根堆（Max Heap）

大根堆是一种完全二叉树，其中每个节点的值都大于或等于其子节点的值。大根堆的根节点是整个堆中的最大值。

‍

#### 维护大根堆的操作

1. **插入**：将新元素插入到堆的末尾，然后向上调整，直到堆的性质恢复。
2. **删除最大值**：将根节点（最大值）与堆的最后一个元素交换，然后删除最后一个元素。接着从根节点开始向下调整，直到堆的性质恢复。

‍

### 小根堆（Min Heap）

小根堆是一种完全二叉树，其中每个节点的值都小于或等于其子节点的值。小根堆的根节点是整个堆中的最小值。

‍

#### 维护小根堆的操作

1. **插入**：将新元素插入到堆的末尾，然后向上调整，直到堆的性质恢复。
2. **删除最小值**：将根节点（最小值）与堆的最后一个元素交换，然后删除最后一个元素。接着从根节点开始向下调整，直到堆的性质恢复。

‍

‍

## 快排快速拷打

高考学生1000万，所有成绩在内存中排序，应该使用什么算法

* 快速排序

使用快速排序什么情况下会复杂度恶化

* 每次都选到最差的划分点

有什么方法优化

* 使用随机函数找划分点

还是可能出现恶化的情况，能用其他算法吗

* 参考sort的原理，递归深度过高时改成堆排序，数据较少的时候改成插入排序

还是觉得不太认可，问有没有更快的排序方法

* 非比较类算法，基数排序

快排为什么比同是nlogn的堆排还有归排好

* 局部性原理
* 不要使用额外空间
